/*jshint
esnext:true,
undef:true
*/
/*global THREE*/
'use strict';

const TWO_PI = 2 * Math.PI;
const HALF_PI = Math.PI / 2;

const tris = [
  new THREE.Vector3( 200, 200 ),
  new THREE.Vector3( 400, 200 ),
  new THREE.Vector3( 0, 100 )
];

const levelText = new Array( 11 );

const keys = [];

let originX;
let originY;

let paused;

let player;
let game;

let focalPoint;

function setup() {
  paused = true;
  size( 800, 800 );

  originX = width  / 2;
  originY = height / 2;

  for ( let i = 0; i < levelText.length; i++ ) {
    levelText[i] = loadShape( 'svg/level' + ( i + 2 ) + '.svg' );
    levelText[i].disableStyle();
  }

  colorMode( HSB, 255 );
  imageMode( CENTER );
  rectMode( CENTER );
  ellipseMode( CENTER );
  shapeMode( CENTER );
  focalPoint = new THREE.Vector3( width / 2, height / 2 );
  noStroke();
  background( 230 );

  player = new Player();
  game = new Game();
  noLoop();

  processingIsReady();
}

function draw() {
  if ( keys[0] || keys[1] || keys[2] || keys[3] ) {
    player.hue += game.speed * 100;
    if ( player.hue > 255 ) {
      player.hue = 0;
    }
  }

  const {
    r,
    vx,
    vy,
    pos: { x, y }
  } = player;

  const halfHeight = height / 2;
  const distance = halfHeight - r - 8;

  if ( keys[0] || keys[1] ) {
    if ( keys[0] ) {
      if ( vy < 0 && dist( x, y, originX, originY + vy ) > distance ) {
        player.vy = 0;
      }
      player.vy += 0.3;
    }

    if ( keys[1] ) {
      if ( vy > 0 && dist( x, y, originX, originY + vy ) > distance ) {
        player.vy = 0;
      }
      player.vy -= 0.3;
    }
  } else if ( vy ) {
    if ( vy > 0 ) {
      player.vy -= 0.5;
      if ( vy < 0 ) {
        player.vy = 0;
      }
    } else if ( vy < 0 ) {
      player.vy += 0.5;
      if ( vy > 0 ) {
        player.vy = 0;
      }
    }
  }

  if ( keys[2] || keys[3] ) {
    if ( keys[2] ) {
      if ( vx < 0 && dist( x, y, originX + vx, originY ) > distance ) {
        player.vx = 0;
      }
      player.vx += 0.3;
    }

    if ( keys[3] ) {
      if ( vx > 0 && dist( x, y, originX + vx, originY ) > distance ) {
        player.vx = 0;
      }
      player.vx -= 0.3;
    }
  } else if ( vx ) {
    if ( vx > 0 ) {
      player.vx -= 0.5;
      if ( vx < 0 ) {
        player.vx = 0;
      }
    } else if ( vx < 0 ) {
      player.vx += 0.5;
      if ( vx > 0 ) {
        player.vx = 0;
      }
    }
  }

  originX += vx;
  originY += vy;

  if ( dist( x, y, originX, originY ) > distance ) {
    const angle = angleTo( player.pos, new THREE.Vector3( originX, originY ) ) - Math.PI;
    originX = x + distance * Math.cos( angle );
    originY = y + distance * Math.sin( angle );
  }

  background( 255 );
  game.update();
}

function onMouseDown() {
  player.speed++;
}

function onKeyDown( event ) {
  const { keyCode } = event;
  // Up. W.
  if ( keyCode === 38 || keyCode === 87 ) { keys[0] = true; }
  // Down. S.
  if ( keyCode === 40 || keyCode === 83 ) { keys[1] = true; }
  // Left. A.
  if ( keyCode === 37 || keyCode === 65 ) { keys[2] = true; }
  // Right. D.
  if ( keyCode === 39 || keyCode === 68 ) { keys[3] = true; }
}

function onKeyUp( event ) {
  const { keyCode } = event;
  if ( keyCode === 38 || keyCode === 87 ) { keys[0] = false; }
  if ( keyCode === 40 || keyCode === 83 ) { keys[1] = false; }
  if ( keyCode === 37 || keyCode === 65 ) { keys[2] = false; }
  if ( keyCode === 39 || keyCode === 68 ) { keys[3] = false; }
}

function pause() {
  if ( paused ) {
    loop();
    paused = false;
    jsStartGame( true );
  } else {
    noLoop();
    paused = true;
  }
}

function newGame() {
  player.reset();
  game.newGame();
}

function getNextScore( indexIn ) {
  if ( indexIn >= game.scores.length ) {
    return 0;
  } else {
    return game.scores[ indexIn ];
  }
}

// Utility functions!
function angleTo( v0, v1 ) {
  let angle = Math.atan2( v0.y - v1.y, v0.x - v1.x );
  if ( angle < 0 ) { angle += TWO_PI; }
  return angle;
}


function drawPolygon( cx, cy, r, numSides, weight, cIn ) {
  const angle = TWO_PI / numSides;
  noFill();
  stroke( cIn );
  strokeWeight( weight );
  beginShape();
  for ( let i = 0; i < numSides; i++ ) {
    vertex(
      cx + r * Math.cos( angle * i ),
      cy + r * Math.sin( angle * i )
    );
  }
  endShape( CLOSE );
}

function easeInExpo( x, t, b, c, d ) {
  return t === 0 ? b : c * Math.pow( 2, 10 * ( t / d - 1 ) ) + b;
}


function sign( x0, y0, x1, y1, x2, y2 ) {
  return ( x0 - x2 ) * ( y1 - y2 ) - ( x1 - x2 ) * ( y0 - y2 );
}

function pointInTriangle( x, y, x0, y0, x1, y1, x2, y2 ) {
  const b0 = sign( x, y, x0, y0, x1, y1 ) < 0;
  const b1 = sign( x, y, x1, y1, x2, y2 ) < 0;
  const b2 = sign( x, y, x2, y2, x0, y0 ) < 0;

  return ( ( b0 === b1 ) && ( b1 === b2 ) );
}

// Thanks, Casey!! :)
// Code adapted from Paul Bourke:
// http://local.wasp.uwa.edu.au/~pbourke/geometry/sphereline/raysphere.c
function circleLineIntersect(
  cx, cy, cr,
  x0, y0,
  x1, y1
) {
  const dx = x1 - x0;
  const dy = y1 - y0;

  const a = dx * dx + dy * dy;
  const b = 2 * ( dx * ( x0 - cx ) + dy * ( y0 - cy ) );
  let c = cx * cx + cy * cy;
  c += x0 * x0 + y0 * y0;
  c -= 2 * ( cx * x0 + cy * y0 );
  c -= cr * cr;

  const discriminant = b * b - 4 * a * c;
  // Not intersecting.
  if ( discriminant < 0 ) {
    return false;
  } else {
    let mu = ( -b + Math.sqrt( b * b - 4 * a * c ) ) / ( 2 * a );
    const ix0 = x0 + mu * dx;
    const iy0 = y0 + mu * dy;

    mu = ( -b - Math.sqrt( b * b - 4 * a * c ) ) / ( 2 * a );
    const ix1 = x0 + mu * dx;
    const iy1 = y0 + mu * dy;

    let testX;
    let testY;
    // Figure out which point is closer to the circle.
    if ( dist( x0, y0, cx, cy ) < dist( x1, y1, cx, cy ) ) {
      testX = x1;
      testY = y1;
    } else {
      testX = x0;
      testY = y0;
    }

    return dist( testX, testY, ix0, iy0 ) < dist( x0, y0, x1, y1 ) ||
           dist( testX, testY, ix1, iy1 ) < dist( x0, y0, x1, y1 );
  }
}

function dist( x0, y0, x1, y1 ) {
  const dx = x1 - x0;
  const dy = y1 - y0;

  return Math.sqrt( dx * dx + dy * dy );
}

function lerp( a, b, t ) {
  return a + t * ( b - a );
}

function inverseLerp( a, b, x ) {
  return ( x - a ) / ( b - a );
}

function map( x, a, b, c, d ) {
  return lerp( c, d, inverseLerp( a, b, x ) );
}

// Create some kind of tree or branch object that takes in an initial triangle
// and a number of limbs.
class Branch {
  constructor(
    a = new THREE.Vector3(),
    b = new THREE.Vector3(),
    c = new THREE.Vector3()
  ) {
    this.vertices = [ a, b, c ];

    // Initialized eased vertices as blanks.
    this.easedVertices = [
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3()
    ];

    this.col = new Color();

    this.minBrightness = 50;
    this.maxBrightness = 90;

    this.hue = 0;
    this.saturation = 0;
    this.brightness = random( this.minBrightness, this.maxBrightness );
    this.alpha = 255;
  }

  setPos( ox, oy, w, h, easedDist ) {
    const [ v0,  v1,  v2  ] = this.vertices;
    const [ ev0, ev1, ev2 ] = this.easedVertices;

    ev0.x = v0.x * easedDist + ( ox - w / 2 );
    ev0.y = v0.y * easedDist + ( oy - h / 2 );
    ev1.x = v1.x * easedDist + ( ox - w / 2 );
    ev1.y = v1.y * easedDist + ( oy - h / 2 );
    ev2.x = v2.x * easedDist + ( ox - w / 2 );
    ev2.y = v2.y * easedDist + ( oy - h / 2 );
  }

  render( ox, oy, w, h, easedDist ) {
    const {
      hue,
      saturation,
      brightness
    } = this;

    const alpha = this.alpha = ( easedDist > 2 ) ?
      Math.floor( map( easedDist, 2, 8, 255, 0 ) ) :
      255;

    if ( easedDist <= 0.8 ) {
      fill( hue, saturation, map( easedDist, 0.0, 0.8, 230, brightness ), alpha );
      stroke( 0, map( easedDist, 0.0, 0.8, 0, 255 ) );
    } else if ( easedDist <= 1.02 ) {
      stroke( 0, alpha );
      fill( hue, saturation, brightness, alpha );
    } else {
      stroke( 255, alpha );
      fill( hue, saturation, 300 - brightness, alpha );
    }

    strokeWeight( 0.4 );

    const [ ev0, ev1, ev2 ] = this.easedVertices;
    triangle(
      ev0.x, ev0.y,
      ev1.x, ev1.y,
      ev2.x, ev2.y
    );
  }

  // Collision detection functions.
  playerOverlap() {
    const {
      r,
      pos: { x, y }
    } = player;

    const [
     { x: x0, y: y0 },
     { x: x1, y: y1 },
     { x: x2, y: y2 }
    ] = this.easedVertices;

    if (
      dist( x, y, x0, y0 ) < r ||
      dist( x, y, x1, y1 ) < r ||
      dist( x, y, x2, y2 ) < r
    ) {
      this.brightness = this.saturation = 100;
      game.gameOver();
    } else if (
      pointInTriangle(
        x, y,
        x2, y2,
        x1, y1,
        x0, y0
      )
    ) {
      this.brightness = this.saturation = 100;
      game.gameOver();
    } else if (
      circleLineIntersect( x, y, r, x0, y0, x1, y1 ) ||
      circleLineIntersect( x, y, r, x1, y1, x2, y2 ) ||
      circleLineIntersect( x, y, r, x2, y2, x0, y0 )
    ) {
      this.brightness = this.saturation = 100;
      game.gameOver();
    }
  }
}

class Layer {
  constructor( numSides, w, h, typeIn ) {
    this.numSides = numSides;
    this.layerWidth = w;
    this.layerHeight = h;
    this.distance = 1;
    this.type = typeIn;

    this.startVertex = 0;
    this.ringWeight = 6;
    this.easedDistance = 0;
    this.passed = false;

    if ( type === 'active' ) {
      const startVertex = this.startVertex = Math.floor( Math.random() * numSides );

      const halfWidth      = this.layerWidth  / 2;
      const halfHeight     = this.layerHeight / 2;
      const halfRingWeight = this.ringWeight  / 2;

      const angle = TWO_PI / this.numSides;

      const ax = halfWidth  + ( halfWidth  - halfRingWeight ) * Math.cos( angle * startVertex );
      const ay = halfHeight + ( halfHeight - halfRingWeight ) * Math.sin( angle * startVertex );
      const bx = halfWidth  + ( halfWidth  - halfRingWeight ) * Math.cos( angle * ( startVertex - 1 ) );
      const by = halfHeight + ( halfHeight - halfRingWeight ) * Math.sin( angle * ( startVertex - 1 ) );

      this.tree = new Tree( 11,
        new Branch(
          new THREE.Vector3( ax, ay ),
          new THREE.Vector3( bx, by ),
          new THREE.Vector3(
            lerp( ax, halfWidth,  0.7 ),
            lerp( ay, halfHeight, 0.7 )
          )
        )
      );
    }
    else {
      this.tree = new Tree();
    }
  }

  updateDist( increment ) {
    this.distance += increment;
    this.easedDistance = easeInExpo( this.distance, this.distance, 0, 1, 1 );
    if ( this.easedDistance >= map( game.speed, 0.0025, 0.008, 0.999, 0.9 ) &&
         this.easedDistance <= map( game.speed, 0.0025, 0.008, 1.02, 1.04 ) ) {
      if ( this.type === 'active' ) {
        tree.checkCollisions();
      } else if ( this.type === 'level' ) {
        if ( game.speed != game.speeds[ game.level - 1 ] ) {
          game.speed = game.speeds[ game.level - 1 ];
          jsIncrementLevel();
        }
      }
    } else if ( this.easedDistance > 1 && !this.passed && this.type === 'active' ) {
      this.passed = true;
      game.score += 100;
      jsUpdateScore( game.score );
      jsTriggerBell();
    }
  }

  getNumSides() {
    return this.numSides;
  }

  reset( typeIn ) {
    this.type = typeIn;
    this.distance = 0;
    this.easedDistance = 0;
    this.passed = false;
    this.tree.reset();
  }

  render() {
    if ( type === 'active' ) {
      tree.render(
        lerp( width  / 2, originX, easedDistance ),
        lerp( height / 2, originY, easedDistance ),
        layerWidth  * easedDistance,
        layerHeight * easedDistance,
        easedDistance
      );
    }
    else if ( type === 'level' ) {
      if ( easedDistance < 0.8 ) {
        fill( map( easedDistance, 0.0, 0.8, 255, 100 ) );
      }
      else {
        const alpha = ( easedDistance > 2 ) ?
          Math.floor( map( easedDistance, 2, 8, 255, 0 ) ) :
          255;
        fill( 100, alpha );
      }
      noStroke();
      shape(
        levelText[ game.level - 2 ],
        lerp( width  / 2, originX, easedDistance ),
        lerp( height / 2, originY, easedDistance ),
        levelText[ game.level - 2 ].width  * easedDistance,
        levelText[ game.level - 2 ].height * easedDistance
      );
    }

    const c = color( 100 );
    drawPolygon(
      lerp( width  / 2, originX, easedDistance ),
      lerp( height / 2, originY, easedDistance ),
      ( layerWidth - ringWeight ) * easedDistance / 2,
      numSides,
      ringWeight * easedDistance,
      c
    );
  }
}

class Tree {
  constructor( numBranches, trunk ) {
    this.numBranches = numBranches;
    this.branches = [];
    for ( let i = 0; i < 16; i++ ) {
      this.branches[i] = new Branch();
    }

    this.index = 0;
    this.trunkLen = 0;

    if ( trunk ) {
      const [ v0, v1, v2 ] = trunk;

      this.branches[ this.index ] = trunk;
      this.index++;
      this.trunkLen = dist(
        lerp( v0.x, v1.x, 0.5 ),
        lerp( v0.y, v1.y, 0.5 ),
        v2.x, v2.y
      );

      this.populateRandomBranches( branches[0], Math.random() );
    }
  }

  populateRandomBranches( trunkIn, sides ) {
    let side;
    if ( sides > 0.2 ) {
      side = 2;
    } else {
      side = Math.floor( Math.random() * 2 );
    }

    const [ v0, v1, v2 ] = trunkIn.vertices;

    const halfWidth  = width  / 2;
    const halfHeight = height / 2;

    if ( ( side === 1 || side === 2 ) && index < numBranches ) {
      const angle = angleTo( v2, v0 ) + Math.random() * HALF_PI;
      const len = dist( v2.x, v2.y, v0.x, v0.y ) * 0.7;

      if ( len > ( trunkLen * 0.4 ) ) {
        // Check if the random angle will fit inside the circle.
        if (
          dist(
            v2.x + len * Math.cos( angle ),
            v2.y + len * Math.sin( angle ),
            halfWidth,
            halfHeight
          ) < halfWidth
        ) {
          branches[ index ] = new Branch(
            new THREE.Vector3( v2.x, v2.y ),
            new THREE.Vector3(
              lerp( v2.x, v1.x, 0.3 ),
              lerp( v2.y, v1.y, 0.3 )
            ),
            new THREE.Vector3(
              v2.x + len * Math.cos( angle ),
              v2.y + len * Math.sin( angle )
            )
          );
          index++;
          this.populateRandomBranches( branches[ index - 1 ], Math.random() );
          // Check if the min or max angle fit inside the area.
        }
        else if (
          dist(
            v2.x + len * Math.cos( angleTo( v2, v0 ) + HALF_PI ),
            v2.y + len * Math.sin( angleTo( v2, v0 ) + HALF_PI ),
            halfWidth,
            halfHeight
          ) < halfWidth ||
          dist(
            v2.x + len * Math.cos( angleTo( v2, v0 ) ),
            v2.y + len * Math.sin( angleTo( v2, v0 ) ),
            halfWidth,
            halfHeight
          ) < halfWidth
        ) {
          this.populateRandomBranches( trunkIn, 1 );
        } // Otherwise, don't do it.
      }
    }


    if ( ( side === 0 || side === 2 ) && index < numBranches ) {
      const angle = angleTo( v2, v1 ) - Math.random() * HALF_PI;
      const len = dist( v2.x, v2.y, v1.x, v1.y ) * 0.7;

      if ( len > ( trunkLen * 0.4 ) ) {
        // Check if the random angle will fit inside the circle.
        if (
          dist(
            v2.x + len * Math.cos( angle ),
            v2.y + len * Math.sin( angle ),
            halfWidth,
            halfHeight
          ) < halfWidth
        ) {
          branches[index] = new Branch(
            new THREE.Vector3(
              lerp( v2.x, v0.x, 0.3 ),
              lerp( v2.y, v0.y, 0.3 )
            ),
            new THREE.Vector3( v2.x, v2.y ),
            new THREE.Vector3(
              v2.x + len * Math.cos( angle ),
              v2.y + len * Math.sin( angle )
            )
          );
          index++;
          this.populateRandomBranches( branches[ index - 1 ], Math.random() );
        }
        else if (
          dist(
            v2.x + len * Math.cos( angleTo( v2, v1 ) - HALF_PI ),
            v2.y + len * Math.sin( angleTo( v2, v1 ) - HALF_PI ),
            halfWidth,
            halfHeight
          ) < halfWidth ||
          dist(
            v2.x + len * Math.cos( angleTo( v2, v1 ) ),
            v2.y + len * Math.sin( angleTo( v2, v1 ) ),
            halfWidth,
            halfHeight
          ) < halfWidth
        ) {
          this.populateRandomBranches( trunkIn, 0 );
        }
      }
    }
  }

  reset() {
    this.index = 1;
    this.numBranches = game.numBranches;

    for ( let i = 1; i < this.numBranches; i++ ) {
      const branch = this.branches[i];
      branch.brightness = Math.floor( random( 50, 200 ) );
      branch.vertices[0].x = 0;
      branch.vertices[0].y = 0;
    }

    const startVertex = this.startVertex = Math.floor( Math.random() * this.numSides );

    const halfWidth      = this.layerWidth  / 2;
    const halfHeight     = this.layerHeight / 2;
    const halfRingWeight = this.ringWeight  / 2;

    const angle = TWO_PI / this.numSides;

    const ax = halfWidth  + ( halfWidth  - halfRingWeight ) * cos( angle * startVertex );
    const ay = halfHeight + ( halfHeight - halfRingWeight ) * sin( angle * startVertex );
    const bx = halfWidth  + ( halfWidth  - halfRingWeight ) * cos( angle * ( startVertex - 1 ) );
    const by = halfHeight + ( halfHeight - halfRingWeight ) * sin( angle * ( startVertex - 1 ) );

    const branch = branches[0] = new Branch(
      new THREE.Vector3( ax, ay ),
      new THREE.Vector3( bx, by ),
      new THREE.Vector3(
        lerp( ax, width / 2, 0.7 ),
        lerp( ay, width / 2, 0.7 )
      )
    );

    const [ v0, v1, v2 ] = branch.vertices;

    trunkLen = dist(
      lerp( v0.x, v1.x, 0.5 ),
      lerp( v0.y, v1.y, 0.5 ),
      v2.x, v2.y
    );

    this.populateRandomBranches( branch, 2 );
  }

  checkCollisions() {
    for ( let i = 0; i < numBranches; i++ ) {
      const branch = this.branches[i];
      if ( branch.vertices[0].x && branch.vertices[0].y ) {
        branch.playerOverlap();
      }
    }
  }

  render( ox, oy, w, h, easedDist ) {
    for ( let i = 0; i < numBranches; i++ ) {
      const branch = this.branches[i];
      if ( branch.vertices[0].x && branch.vertices[0].y ) {
        branch.setPos( ox, oy, w, h, easedDist );
        branch.render( ox, oy, w, h, easedDist );
      }
    }
  }
}

class Player {
  constructor() {
    this.pos = new THREE.Vector3( width / 2, height / 2 );
    this.r = 20;
    this.hue = 0;

    this.speed = 6;
    this.vx = 0;
    this.vy = 0;
  }

  reset() {
    this.pos.x = width / 2;
    this.pos.y = width / 2;
    this.r = 20;

    this.speed = 6;
    this.vx = 0;
    this.vy = 0;
  }
}

const speeds = [
  0.0025,
  0.003,
  0.0035,
  0.004,
  0.0045,
  0.005,
  0.0055,
  0.006,
  0.0065,
  0.007,
  0.0075,
  0.008
];

const scores = [
  0,
  500,
  2000,
  4000,
  6500,
  9500,
  13000,
  18000,
  24000,
  31000,
  39000,
  48000
];


// Tree has been moved inside layer as an internal class.
class Game {
  constructor() {
    this.score = 0;
    this.origin = 'I EXIST';
    this.layers = [];

    this.drawnPlayer = false;
    this.isGameOver = false;
    this.numBranches = 6;
    this.level = 1;
    this.levelUp = 3;
    this.speed = speeds[0];

    // Make layers.
    for ( let i = 0; i < 13; i++ ) {
      this.layers.push( new Layer( 16, width, height, 'inactive' ) );
    }

    // Set the distance var for these 6 layers.
    for ( let i = this.layers.length - 1; i >= 0; i-- ) {
      const layer = this.layers[i];
      layer.distance = 1.3 / this.layers.length * i;
      layer.easedDistance = easeInExpo( layer.distance, layer.distance, 0, 1, 1 );
    }
  }

  update() {
    this.drawnPlayer = false;
    if ( this.isGameOver ) {
      return;
    }

    for ( let i = 0; i < layers.length; i++ ) {
      const layer = layers[i];
      if ( layer.easedDistance > 8 && i === this.layers.length - 1 ) {
        this.layers.unshift( layer );
        this.layers.pop();
        this.checkLevel();
        if ( this.levelUp === 0 || this.levelUp === 2 ) {
          layer.reset( 'inactive' );
          this.levelUp++;
        } else if ( levelUp === 1 ) {
          layer.reset( 'level' );
          this.levelUp++;
        } else {
          layer.reset( 'active' );
        }
      } else {
        layer.updateDist( speed );
        if ( !this.isGameOver ) {
          if ( layer.easedDistance >= 1 && !this.drawnPlayer ) {
            this.drawPlayer();
          }

          layer.render();
        }
      }
    }
  }

  drawPlayer() {
    noStroke();
    fill( 0, 100, 100, 200 );
    ellipse( width / 2, height / 2, player.r * 2, player.r * 2 );
    drawPolygon(
      lerp( width  / 2, originX, 1 ),
      lerp( height / 2, originY, 1 ),
      width / 2,
      16,
      6,
      color( 0, 0, 0 )
    );
    this.drawnPlayer = true;
  }

  checkLevel() {
    const { score, level } = this;

    if ( score > scores[11] && level < 12 ) {
      this.level = 12;
      this.numBranches = 16;
      this.levelUp = 0;
    } else if ( score > scores[10] && level < 11 ) {
      this.level = 11;
      this.numBranches = 16;
      this.levelUp = 0;
    } else if ( score > scores[9] && level < 10 ) {
      this.level = 10;
      this.numBranches = 15;
      this.levelUp = 0;
    } else if ( score > scores[8] && level < 9 ) {
      this.level = 9;
      this.numBranches = 14;
      this.levelUp = 0;
    } else if ( score > scores[7] && level < 8 ) {
      this.level = 8;
      this.numBranches = 13;
      this.levelUp = 0;
    } else if ( score > scores[6] && level < 7 ) {
      this.level = 7;
      this.numBranches = 12;
      this.levelUp = 0;
    } else if ( score > scores[5] && level < 6 ) {
      this.level = 6;
      this.numBranches = 11;
      this.levelUp = 0;
    } else if ( score > scores[4] && level < 5 ) {
      this.level = 5;
      this.numBranches = 10;
      this.levelUp = 0;
    } else if ( score > scores[3] && level < 4 ) {
      this.level = 4;
      this.numBranches = 9;
      this.levelUp = 0;
    } else if ( score > scores[2] && level < 3 ) {
      this.level = 3;
      this.numBranches = 8;
      this.levelUp = 0;
    } else if ( score > scores[1] && level < 2 ) {
      this.level = 2;
      this.numBranches = 7;
      this.levelUp = 0;
    }
  }

  newGame() {
    this.score = 0;
    this.numBranches = 6;
    this.level = 1;
    this.speed = speeds[0];
    this.isGameOver = false;
    this.layers = [];

    originX = width  / 2;
    originY = height / 2;

    for ( let i = 0; i < 13; i++ ) {
      this.layers.push(
        new Layer( 16, width, height, i < 4 ? 'active' : 'inactive' )
      );
    }

    // Set the distance var for these 6 layers.
    for ( let i = this.layers.length - 1; i >= 0; i-- ) {
      const layer = this.layers[i];
      layer.distance = 1.3 / this.layers.length * i;
      layer.easedDistance = easeInExpo( layer.distance, layer.distance, 0, 1, 1 );
    }

    redraw();
  }

  gameOver() {
    if ( !this.isGameOver ) {
      jsGameOver( this.score );
      this.isGameOver = true;
      background( 0, 0, 255 );
      for ( let i = 0; i < this.layers.length; i++ ) {
        this.layers[i].render();
      }

      noLoop();
      paused = true;
    }
  }
}
